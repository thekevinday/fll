# fss-0002
#
# license: cc-by-sa-4.0
#

Cygwin:
  The following are a collection of informal notes on getting this to compile and run under Windows using Cygwin.
  I may formalize this at a later point in time.

  I have tested and was able to successfully (statically) compile and run FLL+Byte Dump under Cygwin.
  The resulting binary could be transfered to another machine and runs if the Cygwin.dll is copied with it (placed along the byte_dump.exe).

  To compile the FLL, some functionality needs to be disabled.
  Fortunately, FLL is specifically designed to be hackable so the process is easier than it might otherwise be.

  For a monolithic build, compiled statically, add the following to "defines" in the "data/build/settings" file (of the packaged source).
    "-D_di_libcap_ -D_pthread_attr_unsupported_ -D_pthread_sigqueue_unsupported_ -D_di_f_thread_attribute_default_get_ -D_di_f_thread_attribute_default_set_ -D_di_compiler_attributes_ -DF_attribute_visibility_hidden_d -DF_attribute_visibility_internal_d -DF_attribute_visibility_protected_d -DF_attribute_visibility_public_d -DF_attribute_weak_d"

  The Cygwin system does not support special link modes, such as "-z now", so remove "-z now" from all build settings files.

  Capabilities are likely unavailable, so remove "-lcap" from any build_libraries references.

  For thread support, it may be necessary to explicitly specify "-lpthread" in addition to "-pthread" in each of the build settings files.

  Before packaging "data/build/settings", the build settings files are either found inside the individual projects or under the build directory at the root of the source repository.

  The file level_1/fl_control_group/c/control_group.c (for function fl_control_group_apply()) had to have the following changed from:
    if (unshare(CLONE_NEWCGROUP) < 0) {
      if (errno == EINVAL) return F_status_set_error(F_parameter);
      if (errno == ENOMEM) return F_status_set_error(F_memory_not);
      if (errno == ENOSPC) return F_status_set_error(F_space_not);
      if (errno == EPERM) return F_status_set_error(F_prohibited);

      return F_status_set_error(F_failure);
    }
  to:
    return F_status_set_error(F_supported_not);

  The file level_0/f_limit/c/limit.c (for function f_limit_process()) had to have the following changed from:
    if (prlimit(id, type, value_next, value_current) < 0) {
      if (errno == EFAULT) return F_status_set_error(F_address_not);
      if (errno == EINVAL) return F_status_set_error(F_parameter);
      if (errno == EPERM) return F_status_set_error(F_prohibited);
      if (errno == ESRCH) return F_status_set_error(F_found_not);

      return F_status_set_error(F_failure);
    }

    return F_none;
  to:
    return F_status_set_error(F_supported_not);

  These changes may be necessary if unshare() or prlimit() are unsupported.

  There may have been other things to disable that I forgot to document.

  I do not believe I had to make any changes to compile byte_dump.

  Compiling byte_dump statically against the FLL library is a bit inefficient in that it contains the entire FLL library.
  The byte_dump program only needs a portion of it.
  I may need to provide a list of everything that can be disabled to provide a smaller and more optimal byte_dump binary.

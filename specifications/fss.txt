# fss-0002

Featureless Settings Specifications:
  A Keep It Simple Stupid specifications for configuration/settings files.

  This specification defines the following\:
  - Will consist of numerous different kinds of specification files, depending on the type of information stored.
  - As with the practice of "#!/bin/bash", the setting files MUST have the following: "# fss-????" format, such as "# fss-0001".
  - With the ? representing the (hexadecimal/base-16) number that represents the particular specification structure.
  - All settings specifications must avoid any form of noise, relative to the data being stored.
  - ie: XML would be considered anti-KISS due to the extreme level of noise generated by the XML language (not easy to read).
  - The settings files are setup so that they produce easy readability on both the console and in a GUI.

  The basic FSS specifications consists of two main parts: an "object" and the "content".
  - Object: considered the name or identifier of some particular data.
  - Content: the data associated with a given Object; all Content must have an associated Object.

  Objects and Contents can include any characters allowed by the specifications.
  The specification may choose, however, how a given Content is represented and parsed.
  For example, in FSS-0000 (Basic), Content is treated as a single item whereas in FSS-0001 (Extended), Content is broken apart in multiple sub parts.

  In all cases, specifications that separate Objects from Contents using whitespace (not newlines), the first whitespace separating the Object and Content must not be consided part of the Object nor part of the Content.
  All spaces after that may be part of the Content as allowed by the given specification.

  Unless explicitly defined by the specification, all specifications are newline sensitive ('\n' only).
  Newline characters are only '\n' and are never anything else ('\r' is not considered newline in any manner).
  Whitespaces characters that are printable, such as tabs and spaces must be considered the same type.
  Non-printing whitespaces characters (zero-width characters) are ignored or are treated as placeholders for processing.
  In terms of processing, it is recommended that the NULL character is not considered the end of a string, but this is only a suggestion.

  Unless explicitly defined, newlines designate the start of a potential new Object or the potential end of some Content.

  Unless explicitly defined, whitespace may exist to the left of the start of objects.

  Unless explicitly defined, whitespace immediately both before and after an object is not considered part of an object.
  This simplifies identifying the object, use quoted objects to support whitespace before/after an object.

  Unless explicitly defined, quotes may only be either a single quote (') or a double quote (") and only a backslash '\' may be used as a delimiter.

  Unless explicitly defined by the specification, character/data delimits are performed only when required and not unilaterally.
  In the case of Objects, delimits would only apply when that object could be potentially identified as an object when it otherwise should not.
  For example, FSS-0001 (Extended) needs quotes to group parts that include spaces, if there is no initial quote, then a quote following the data must not be delimited.
  Such as these following two lines\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content"
    Object_2 This is multiple" Contents and the trailing quote does not need to be delimited.

  Unlike this specification, a more traditional delimit process would have the above two lines instead represented as\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content\"
    Object_2 This is multiple\" Contents and the trailing quote does not need to be delimited.

  Unless explicitly defined, delimits may be delimited by the delimit character (a backslash '\').
  For example, FSS-0000 (Basic):
    \"Object 1" has content starting at the '1', with an Object named '"Object'.
    \\"Object 1" has content starting at the '1', with an Object named '\"Object'.
    "Object 1\" is an unterminated object due to the escaped closing quote.
    "Object 1\\" has content starting at the 'has', with an Object named "Object 1\".

  All specifications are expected to support or be of the character encoding UTF-8; however, there is no imposed restriction on supporting or using any other encoding.
  Those encodings must only support the appropriate characters required by a given standard for differentiating Objects, Contents, and delimits.

  Unless explicitly defined, comments are designated by the pound symbol '#' but only if only whitespace is to the left of the pound or the pound '#' is at the start of the line.
  There is no support for inline comments.
  Unless explicitly defined, the start comment may be delimited by '\' in the same manner as Objects and Contents are.
  This delimit only applies to the start of a comment (the pound '#' character) as there is no terminating character for a comment (other than a newline '\n').

  Unless explicitly defined, all designation characters must represent ASCII codes.
  With designation characters being any character code used to designate how to identify an Object or Content (such as a colon ':' at the end of a basic list).
  This keeps the processing and logic simple, for both UTF-8 and ASCII.
  Whitespace used for designation characters must include support for UTF-8 whitespace characters, unless explicitly designated not to by a standard.
  Control characters used for designation characters must include support UTF-8 control character support, unless explicitly designated not to by a standard.

  The UTF-8 BOM is not allowed as a Byte Order Mark; instead, it must always be treated as the character represented by its code (unless explicitly allowed by a standard).

  The follow specifications are defined in this project.
  Each of these specifications has a common name associated with the specification number.
  - fss-0000: Basic
  - fss-0001: Extended
  - fss-0002: Basic List
  - fss-0003: Extended List
  - fss-0004: Very Basic List
  - fss-0005: Somewhat Basic List
  - fss-0006: Somewhat Extended List
  - fss-0007: Very Extended List
  - fss-0008: Embedded List
  - fss-0009: Reverse Mapping
  - fss-000A: Extended Reverse Mapping
  - fss-000B: Simple Json
  - fss-000C: Simple List

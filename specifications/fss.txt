# fss-0002

Featureless Settings Specifications:
  A Keep It Simple Stupid specifications for configuration/settings files.

  This specification defines the following\:
  - Will consist of numerous different kinds of specification files, depending on the type of information stored.
  - As with the practice of "#!/bin/bash", the setting files MUST have the following: "# fss-????" format, such as "# fss-0001".
  - Multiple sub-standards may be appended to the FSS header, using the same format structure, such as supporting IKI: "# fss-???? iki-????" (or in theory, HTML5, such as: "# fss-???? html-0005").
  - With the ? representing the (hexadecimal/base-16) number that represents the particular specification structure.
  - All settings specifications must avoid any form of noise, relative to the data being stored.
  - ie: XML would be considered anti-KISS due to the extreme level of noise generated by the XML language (not easy to read).
  - The settings files are setup so that they produce easy readability on both the console and in a GUI.

  The basic FSS specifications consists of two main parts: an "object" and the "content".
  - Object: considered the name or identifier of some particular data.
  - Content: the data associated with a given Object; all Content must have an associated Object.

  Objects and Contents can include any characters allowed by the specifications.
  The specification may choose, however, how a given Content is represented and parsed.
  For example, in FSS-0000 (Basic), Content is treated as a single item whereas in FSS-0001 (Extended), Content is broken apart in multiple sub parts.

  In all cases, specifications that separate Objects from Contents using whitespace (not newlines), the first whitespace separating the Object and Content must not be consided part of the Object nor part of the Content.
  All spaces after that may be part of the Content as allowed by the given specification.

  Unless explicitly defined by the specification, all specifications are newline sensitive ('\n' only).
  Newline characters are only '\n' and are never anything else ('\r' is not considered newline in any manner).
  Whitespaces characters that are printable, such as tabs and spaces must be considered the same type.
  Non-printing whitespaces characters (zero-width characters) are ignored or are treated as placeholders for processing (this includes zero-width punctutations characters and similar).
  In terms of processing, it is recommended that the NULL character is not considered the end of a string, but this is only a suggestion.

  Unless explicitly defined, newlines designate the start of a potential new Object or the potential end of some Content.

  Unless explicitly defined, whitespace may exist to the left of the start of objects.

  Unless explicitly defined, whitespace immediately both before and after an object is not considered part of an object.
  This simplifies identifying the object, use quoted objects to support whitespace before/after an object.

  Unless explicitly defined, quotes may only be either a single quote (') or a double quote (") and only a backslash '\' may be used as a delimiter.
  For example, FSS-0000 (Basic)\:
    \"Object 1" has content starting at the '1', with an Object named '"Object'.
    \\"Object 1" has content starting at the '1', with an Object named '\"Object'.
    "Object 1\" is an unterminated object due to the escaped closing quote.
    "Object 1\\" has content starting at the 'has', with an Object named "Object 1\".

  Unless explicitly defined by the specification, character/data delimits are performed only when required and not unilaterally.
  In the case of Objects, delimits would only apply when that object could be potentially identified as an object when it otherwise should not.
  For example, FSS-0001 (Extended) needs quotes to group parts that include spaces, if there is no initial quote, then a quote following the data must not be delimited.
  Such as these following three lines\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content."
    Object_2 This is multiple" Contents and the trailing quote does not need to be delimited.
    "Object \"3" 'Wouldn't require delimits if no whitespace or end of string after.'

  Unlike this specification, a more traditional delimit process would have the above three lines instead represented as\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content.\"
    Object_2 This is multiple\" Contents and the trailing quote does not need to be delimited.
    "Object \\"3" 'Wouldn\'t require delimits if no whitespace or end of string after.'

  These examples would resolve as follows\:
    1) Object\:
      - Object 1
       Content\:
      - This is a single quoted Content.
      - "Additional
      - unquoted
      - Content"
    2) Object\:
      - Object_2
       Content\:
      - This
      - is
      - multiple"
      - Contents
      - and
      - the
      - trailing
      - quote
      - does
      - not
      - need
      - to
      - be
      - delimited.
    3) Object\:
      - Object \"3
       Content\:
      - Wouldn't require delimits if no whitespace or end of string after.

  All specifications are expected to support or be of the character encoding UTF-8; however, there is no imposed restriction on supporting or using any other encoding.
  Those encodings must only support the appropriate characters required by a given standard for differentiating Objects, Contents, and delimits.

  Unless explicitly defined, comments are designated by the pound symbol '#' but only if only whitespace is to the left of the pound or the pound '#' is at the start of the line.
  There is no support for inline comments.
  Unless explicitly defined, the start comment may be delimited by '\' in the same manner as Objects and Contents are.
  This delimit only applies to the start of a comment (the pound '#' character) as there is no terminating character for a comment (other than a newline '\n').

  Unless explicitly defined, all designation characters must represent ASCII codes.
  With designation characters being any character code used to designate how to identify an Object or Content (such as a colon ':' at the end of a basic list).
  This keeps the processing and logic simple, for both UTF-8 and ASCII.
  Whitespace used for designation characters must include support for UTF-8 whitespace characters, unless explicitly stated otherwise.
  Control characters used for designation characters must include support UTF-8 control character support, unless explicitly stated otherwise.

  The UTF-8 BOM is not allowed as a Byte Order Mark; instead, it must always be treated as the character represented by its code (unless explicitly allowed to represent a BOM by a standard).

  Unless explicitly defined, whitespace is to be considered all not visible characters that take up space (including newlines '\n').
  Any visible/graph character that is considered a whitespace (such as U+1680 ' ') is not to be considered a whitespace.

  When used for syntax matching purposes, zero-width Unicode characters are only to be considered zero-width unless explicitly stated otherwise.
  For example, the "invisible plus" character (U+2064) is not to be considered as a plus (unless explicitly stated otherwise).

  The only Unicode dash-like characters allowed as a "dash" are those intended to connect, such as the Unicode hyphens (U+2010 and U+2011) (unless explicitly stated otherwise).

  In any specification where security is intended, if there exists a Unicode character that matches an ASCII character, that Unicode character may potentially be prohibeted by that standard in favor of the ASCII equivalent.
  One such example is in the case of a URL, where the name could be used to trick a person (http://this-site.com/ vs http://this‐site.com/).
  This (potential insecure behavior) is allowed in general because a well written program would be able to detect and communicate the possible misunderstanding and thereby avoid mistakes without imposing any character restrictions.

  @todo document that certain special UTF-8 characters are not allowed in certain terminology groups, such as "word characters", "number characters", etc.. so that potential confusion can be avoided.
  This is a common behavior for security reasons, each character used for any special purposes must be visibly distinct, with whitespace and non-printing characters as the exception to the words "visibly distinct".

  The follow specifications are defined in this project.
  Each of these specifications has a common name associated with the specification number.
  - fss-0000: Basic
  - fss-0001: Extended
  - fss-0002: Basic List
  - fss-0003: Extended List
  - fss-0004: Very Basic List
  - fss-0005: Somewhat Basic List
  - fss-0006: Somewhat Extended List
  - fss-0007: Very Extended List
  - fss-0008: Embedded List
  - fss-0009: Reverse Mapping
  - fss-000A: Extended Reverse Mapping
  - fss-000B: Simple Json
  - fss-000C: Simple List
  - fss-000D: Iki Text

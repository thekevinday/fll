# fss-0002

Featureless Settings Specifications:
  A Keep It Simple Stupid specifications for configuration/settings files.

  This specification defines the following\:
  - Will consist of numerous different kinds of specification files, depending on the type of information stored.
  - As with the practice of "#!/bin/bash", the setting files MUST have the following: "# fss-????" format, such as "# fss-0001".
  - With the ? representing the (hexadecimal/base-16) number that represents the particular specification structure.
  - All settings specifications must avoid any form of noise, relative to the data being stored.
  - ie: XML would be considered anti-KISS due to the extreme level of noise generated by the XML language (not easy to read).
  - The settings files are setup so that they produce easy readability on both the console and in a GUI.

  The basic FSS specifications consists of two main parts: an "object" and the "content".
  - Object: considered the name or identifier of some particular data.
  - Content: the data associated with a given Object; all Content must have an associated Object.

  Objects can include any characters allowed by the specifications.
  Contents should allow any data and the specification has to allow it in some way.
  The specification may chose, however, how a given Content is represented and parse.
  For example, in FSS-0000 (Basic), Content is treated as a single item whereas in FSS-0001 (Extended), Content is broken apart in multiple sub parts.

  Unless explicitly defined by the specification, all specifications are newline sensitive ('\n' only).
  Newline characters are only '\n' and are never anything else (\r is not considered newline in any manner).
  Whitespaces characters that are printable, such as tabs and spaces must be considered the same type.
  Non-printing whitespaces characters are ignored or are treated as placeholders for processing.
  In terms of processing, it is recommended that the NULL character is not considered the end of a string, but this is only a suggestion.

  Unless explicitly defined, newlines designate the start of a potential new Object or the potential end of some Content.

  Unless explicitly defined, whitespace may exist to the left of the start of objects.

  Unless explicitly defined, whitespace immediately both before and after an object is not considered part of an object.
  This simplifies identifying the object, use quoted objects to support whitespace before/after an object.

  Unless explicitly defined, quotes may only be either a single quote or a double quote and only a backslash may be used as a delimiter.

  Unless explicitly defined by the specification, character/data delimits are performed only when required and not unilaterally.
  In the case of Objects, delimits would only apply when that object could be potentially identified as an object when it otherwise should not.
  For example, FSS-0001 (Extended) needs quotes to group parts that include spaces, if there is no initial quote, then a quote following the data must not be delimited.
  Such as these following two lines\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content"
    Object_2 This is multiple" Contents and the trailing quote does not need to be delimited.

  Unlike this specification, a more traditional delimit process would have the above two lines instead represented as\:
    "Object 1" "This is a single quoted Content." \"Additional unquoted Content\"
    Object_2 This is multiple\" Contents and the trailing quote does not need to be delimited.

  All specifications are expected to support or be of the character encoding UTF-8; however, there is no imposed restriction on supporting or using any other encoding.
  Those encodings must only support the appropriate characters required by a given standard for differentiating Objects, Contents, and delimits.

  Unless explicitly defined, comments are designated by the pound symbol '#' but only if only whitespace is to the left of the pound.
  There is no support for inline comments.

  Unless explicitly defined, all designation characters must be in ASCII.
  With designation characters being any character code used to designate how to read a file (such as a colon ':' at the end of a basic list).
  This keeps the processing and logic simple, for UTF-8.
  Whitespace used for designation characters must include support UTF-8 whitespace characters, unless explicitly designate not to.
  Control characters used for designation characters must include support UTF-8 control character support, unless explicitly designate not to.

  The UTF-8 BOM is not allowed as a "BOM", instead it must always be treated as the character represented by its code (unless explicitly allowed).

  The follow specifications are defined in this project.
  Each of these specifications has a common name associated with the specification number.
  - fss-0000: Basic
  - fss-0001: Extended
  - fss-0002: Basic List
  - fss-0003: Extended List
  - fss-0004: Very Basic List
  - fss-0005: Somewhat Basic List
  - fss-0006: Somewhat Extended List
  - fss-0007: Very Extended List
  - fss-0008: Embedded List
  - fss-0009: Reverse Mapping
  - fss-000A: Extended Reverse Mapping
  - fss-000B: Simple Json
  - fss-000C: Simple List
